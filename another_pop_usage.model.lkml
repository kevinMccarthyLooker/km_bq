connection: "biquery_publicdata_standard_sql"

# include: "/events.view.lkml"
include: "/views/trip.view"

# include: "/order_items_explore"
view: +trip {
#   derived_table: {
#     sql:
#     {%if version._is_selected%}
#     (select * from
#     (
#     ${EXTENDED}
#     )
#     base
#     cross join
#     (select 'current' as version union all
#      select 'prior' as version) versions)
#     {%else%}
#     ${EXTENDED}
#     {%endif%}
#     ;;
#   }

##for sql_table_name based, instead use this version... one set of parenthesis removed:
sql_table_name:
{%if version._is_selected%}
(select * from

${EXTENDED}

base
cross join
(select 'current' as version union all
 select 'prior' as version) versions)
{%else%}
${EXTENDED}
{%endif%}
;;

  dimension: version {}#_is_selected is checked on this field to.  Makes source data duplicate, and makes targeted date fields handle date manipulation

#override the target dimension: paste this sql override.  timezone conversion applied manually because we need to convert first before manipulating dates
  dimension_group: start{
    convert_tz: no
    datatype: timestamp
    #for prior period data (generated by cross join), we adjust dates to align with the current period
    #exact time functions vary by dialect
    #to do: test/handle all source datatypes
    sql:
    timestamp(
    {%if version._is_selected%}
    case when version = 'prior' then datetime_add(
    cast(
    TIMESTAMP(FORMAT_TIMESTAMP('%F %T', TIMESTAMP(FORMAT_TIMESTAMP('%F %H:%M:%E*S',
    ${EXTENDED}
    ,'{{_query._query_timezone}}'))))
    as datetime)
    ,interval 1 year)
    else
    {%endif%}
    cast(
    TIMESTAMP(FORMAT_TIMESTAMP('%F %T', TIMESTAMP(FORMAT_TIMESTAMP('%F %H:%M:%E*S',
    ${EXTENDED}
    ,'{{_query._query_timezone}}'))))
    as datetime)
    {%if version._is_selected%}
    end
    {%endif%}
    )
    ;;
  }

  dimension_group: stop{
    convert_tz: no
    #for prior period data (generated by cross join), we adjust dates to align with the current period
    #exact time functions vary by dialect
    #to do: test/handle all source datatypes
    sql:
    timestamp(
    {%if version._is_selected%}
    case when version = 'prior' then datetime_add(
    cast(
    TIMESTAMP(FORMAT_TIMESTAMP('%F %T', TIMESTAMP(FORMAT_TIMESTAMP('%F %H:%M:%E*S',
    ${EXTENDED}
    ,'{{_query._query_timezone}}'))))
    as datetime)
    ,interval 1 year)
    else
    {%endif%}
    cast(
    TIMESTAMP(FORMAT_TIMESTAMP('%F %T', TIMESTAMP(FORMAT_TIMESTAMP('%F %H:%M:%E*S',
    ${EXTENDED}
    ,'{{_query._query_timezone}}'))))
    as datetime)
    {%if version._is_selected%}
    end
    {%endif%}
    )
    ;;
  }

}

explore: trip {
#   query: test {dimensions: [period_over_period_support.version,period_over_period_support.evaluation_date]}
#   join: period_over_period_support {
#     type: cross
#     relationship: one_to_one
#   }
}
